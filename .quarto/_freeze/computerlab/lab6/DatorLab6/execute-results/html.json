{
  "hash": "0724a148d6bf756e9aa36b6a2da9cbce",
  "result": {
    "markdown": "---\ntitle: \"Statistik och dataanalys I, 15 hp \"\nsubtitle: \"Datorlaboration 6 - Konfidensintervall, hypotesttest och centrala gr칛nsv칛rdessatsen\"\nauthor: \n  - Mattias Villani\ndate: last-modified\nformat: \n  html:\n    self-contained: true\ntoc: true\nexecute:\n  error: false\nlanguage: \n  title-block-author-single: \" \"\ntoc-title-document: \"Inneh친ll\"\ncrossref-fig-title: \"Figur\"\ntheme: Superhero\ntitle-block-banner-color: Primary\ntitle-block-published: \"Publicerad\"\ncallout-warning-caption: \"Varning\"\ncallout-note-caption: \"Observera\"\ncallout-tip-caption: \"Tips\"\neditor: visual\n---\n\n\n## Introduktion och viktig f칬rberedande information\n\n> I den h칛r datorlabben kommer vi att arbeta med konfidensintervall och hypotestest\n\n::: callout-warning\n## Installera paket\n\nDen h칛r labben f칬ruts칛tter inga installerade paket.\n:::\n\n::: callout-important\n## Skapa mapp f칬r labben\n\nSkapa en mapp `Lab6` i din kursmapp SDA1. Ladda ner Quarto-filen f칬r denna lab genom att h칬gerklicka [h칛r](https://github.com/StatisticsSU/SDA1/raw/main/datorlab/lab6/DatorLab6.qmd) och v칛lj 'Spara l칛nk' eller n친got likande fr친n menyn som dyker upp. Spara filen i din `Lab6` mapp. 칐ppna Quarto-filen i RStudio och forts칛tt med denna laboration direkt i Quarto-dokumentet, d칛r du ocks친 fyller i svaren p친 dina laborations칬vningar.\n:::\n\n### Looping as a way of life\n\nI den h칛r uppgiften kommer ni beh칬va **upprepa** ber칛kningar ett stort antal g친nger. D친 anv칛nder vi **loopar**, framf칬rallt den s k `for`-loopen. H칛r 칛r en enkel loop som ber칛knar kvadraten av alla tal mellan 1 och 10 och sparar resultaten i en vektor `kvadrater`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkvadrater = rep(0, 10) # Skapar vektor med nollor d칛r vi sen sparar varje kvadrat\nfor (i in 1:10){\n  kvadrater[i] = i^2\n}\nkvadrater\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n:::\n:::\n\n\nVi kan g칬ra precis samma loop p친 lite annorlunda s칛tt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkvadrater = rep(0, 10) \nmin_loop_vektor = 1:10\nfor (i in min_loop_vektor){\n  kvadrater[i] = i^2\n}\n```\n:::\n\n\nNotera att R allts친 kan loop:a 칬ver vilken vektor som helst. R l칛ser `for`-loopen ovan som 'upprepa kommandot `print(i^2)` f칬r alla v칛rden p친 `i` tagna fr친n vektorn `min_loop_vektor` och spara resultatet i den `i`:te positionen i vektorn `kvadrater`.\n\nGenom att anv칛nda `seq()` funktionen kan vi t ex loop:a 칬ver v칛rdena 0.1, 0.2,..., 0.9, 1 s친 h칛r:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_loop_vektor = seq(0.1, 1, by = 0.1)\nfor (i in min_loop_vektor){\n  print(i^2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.01\n[1] 0.04\n[1] 0.09\n[1] 0.16\n[1] 0.25\n[1] 0.36\n[1] 0.49\n[1] 0.64\n[1] 0.81\n[1] 1\n```\n:::\n:::\n\n\nMen hur g칬r vi om vi vill spara dessa kvadrater i en vektor `kvadrater` som vi gjorde ovan? Vi kan inte l칛ngre anv칛nda loop-variabeln `i` f칬r tala om f칬r R att placera kvadraten `i^2` p친 den `i`:te positionen i `kvadraten`. Variabeln `i` r칛knar ju inte l칛ngre fr친n 1 till 10! Den r칛knar ju 0.1, 0.2,..., 0.9, 1.\n\nL칬sningen 칛r att skapa ytterligare en variabel som h친ller reda p친 var i vektorn `kvadrater` som resultat ska sparas. Jag kallar den variabel `count`, men den kan heta vad som helst.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkvadrater = rep(0, 10)\nmin_loop_vektor = seq(0, 1, by = 0.1)\ncount = 0\nfor (i in min_loop_vektor){\n  count = count + 1\n  kvadrater[count] = i^2\n}\nkvadrater\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.00 0.01 0.04 0.09 0.16 0.25 0.36 0.49 0.64 0.81 1.00\n```\n:::\n:::\n\n\nNotera hur jag f칬rst satte `count` till `0` innan loopen och hur jag sen inne i loopen 칬kade `count` med ett i varje upprepning.\n\nOk, nu testar vi den h칛r kunskapen p친 ett lite, lite mer avancerat problem. S칛g att vi vill simulera fr친n samplingf칬rdelningen f칬r stickprovsandelen $\\hat p$ med data fr친n modellen\n\n$$\nX_1,X_2,\\ldots,X_n \\overset{iid}{\\sim}\\mathrm{Bernoulli}(p)\n$$\n\nd칛r *p=0.3* och stickprovsstorleken *n=100*. Vi g칬r detta genom att simulera 1000 olika stickprov fr친n modellen. F칬r varje stickprov med *n=100* observationer ber칛knar vi andelen $\\hat p$ och sparar denna andel i en l친ng vektor. Sen plottar vi f칬rdelningen av dessa 1000 st v칛rden p친 $\\hat p$ med ett histogram. Here we go!\n\n\n::: {.cell}\n\n```{.r .cell-code}\np = 0.3              # andelen i populationen/modellen\nnsim = 1000          # vi vill simulera 1000 olika stickprov\nn = 100              # varje stickprov best친r av 100 observationer.\nphats = rep(0, nsim) # skapar vektor d칛r andelen (phat) i varje stickprov sparas.\ncount = 0            \nfor (i in 1:nsim){\n  count = count + 1\n  x = rbinom(n, size = 1, prob = p) # size = 1 g칬r att binomialf칬rdelningen blir en Bernoulli.\n  phats[count] = mean(x)            # mean(x) ger oss andelen phat.\n}\nhist(phats, 50)\n```\n\n::: {.cell-output-display}\n![](DatorLab6_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nSom en sista 칬vning med loopar, l친t oss ber칛kna sannolikheten $P(X\\leq 0.5)$ f칬r en Bernoulli-variabel med sannolikheten $p$ d칛r vi varierar $p$ mellan 0 och 1 i steg av 0.01:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nps = seq(0, 1, by = 0.01)\nprobability = rep(0, length(ps)) # funktionen length() r칛knar antalet element in en vektor\ncount = 0            \nfor (p in ps){   # man f친r anv칛nda annat namn 칛n i som loop-variabel\n  count = count + 1\n  probability[count] = pbinom(0.5, size = 1, prob = p)  # p 칛ndras i varje upprepning\n}\nplot(ps, probability, type = \"l\", xlab = \"p\", ylab = \"P(X<=0.5)\")\n```\n\n::: {.cell-output-display}\n![](DatorLab6_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## 1. Konfidensintervall och test f칬r en andel\n\n#### 游눩 Uppgift 1.1\n\nP친 f칬rel칛sningen om konfidensintervall f칬r en andel s친g vi att andelen S-v칛ljare *p* skattades till 0.371 i SVT/Novus unders칬kning i Februari 2023 baserat p친 ett stickprov av *n=3539* personer d칛r allts친 1313 person angav att de skulle r칬sta p친 S. Vi s친g ocks친 att ett 95% konfidensintervall f칬r *p* var (0.355, 0.387).\n\nM친naden innan (SVT/Novus, Januari 2023) skattades andelen S-v칛ljare till 0.347 (samma antal personer tillfr친gades och 1228 personer angav att de skulle r칬sta p친 S). Anv칛nd funktionen `prop.test` f칬r att ber칛kna ett 95% konfidensintervall f칬r *p* i Januari 2023.\n\nBer칛kna 칛ven detta konfidensintervall med formeln\n\n$$\n\\hat p \\pm z_{\\alpha/2}\\cdot\\sqrt{\\frac{pq}{n}}\n$$\n\nAnv칛nd konfidensintervallen f칬r Januari och Februari 2023 f칬r att f칬rklara Novus p친st친ende (vad g칛ller S):\n\n*I den senaste unders칬kningen fr친n SVT/Novus (*Februari 2023) *칛r ingen f칬r칛ndring statistiskt s칛kerst칛lld.*\n\n#### 游눩 Uppgift 1.2\n\nI senaste valet fick S 30,33% av r칬sterna. Anv칛nda `prop.test` f칬r att testa p친 5% signifikansniv친 om andelen S-v칛ljare i i Februari 2023 칛r f칬r칛ndrat sedan valet.\n\n## 2. Konfidensintervall och test f칬r ett v칛ntev칛rde\n\nI 칐vning 20.65 i SDA-boken analyseras data f칬r m칛ngden socker i frukostflingor (gram per 100 gram flingor) f칬r flingor som riktar sig till barn (`child_sugar`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchild_sugar = c(40.3,55.0,45.7,43.3,50.3,45.9,53.5,43,44.2,44,47.4,44,33.6,55.1,48.8,50.4,37.8,60.3,46.6)\n```\n:::\n\n\nL친t oss analysera `child_sugar` med modellen\n\n$$X_1,X_2,\\ldots,X_n \\overset{iid}{\\sim}N(\\mu,\\sigma)$$\n\n#### 游눩 Uppgift 2.1\n\nAnv칛nd R f칬r att ber칛kna ett 95%-igt konfidensintervall f칬r $\\mu$, b친de genom att anv칛nda formeln\n\n$$\\bar x \\pm t_{\\alpha/2,n-1}\\frac{s}{\\sqrt n}$$\n\noch genom att anv칛nda funktionen `t.test`.\n\n#### 游눩 Uppgift 2.2\n\nAnv칛nd funktionen `t.test` f칬r att utf칬ra testet:\n\n$$\n\\begin{align}\n&H_0: \\mu = 50 \\\\\n&H_1:\\mu\\neq50\n\\end{align}\n$$\n\ngenom att ber칛kna *p*-v칛rdet f칬r testet och f칬rkasta $H_0$ om *p*-v칛rdet 칛r mindre 칛n $\\alpha =0.05$. Dvs testa p친 5% signifikansniv친. Tolka resultatet fr친n testet.\n\n#### 游눩 Uppgift 2.3\n\nUpprepa testet i uppgiften ovan f칬r olika v칛rden p친 nollhypotesens v칛rde, $\\mu_0$. Prova alla v칛rden p친 nollhypotesen $\\mu_0$ i vektorn `seq(40, 50, by = 0.1)`, dvs utf칬r testet i uppgiften ovan med $\\mu_0 = 40$, sen med $\\mu_0=40.1$ osv 칛nda till $\\mu_0=50$. Registera om du f칬rkastar $H_0$ eller inte f칬r varje v칛rde p친 $\\mu_0$. F칬r vilka v칛rden p친 $\\mu_0$ f칬rkastar du $H_0$? J칛mf칬r med konfidensintervallet i Uppgift 2.1.\n\n::: callout-tip\n## Tips\n\nAnv칛nd en for-loop f칬r att loop:a 칬ver alla v칛rden p친 $\\mu_0$. Anv칛nd min kod ovan som ber칛kna sannolikheten $P(X\\leq 0.5)$ f칬r en Bernoulli-variabel med sannolikheten $p$ som en mall f칬r denna loop.\n\nResultatet fr친n `t.test` 칛r en lista. S친 anv칛nd \\$-tecknet f칬r att plocka ut *p*-v칛rdet fr친n resultat-listan fr친n testet (t ex `resultat$p.value`) om du sparat resultatet fr친n `t.test` i variabeln `resultat`).\n:::\n\n#### 游눩 Uppgift 2.4\n\nDu 칛r egentligen intresserad av att bevisa att den genomsnittliga sockerm칛ngden i barnflingor 칛r **mer** 칛n 40 gram. Dvs, du vill testa den enkelsidiga hypotesen p친 signifikansniv친n $\\alpha =0.05$:\n\n$$\n\\begin{align}\n&H_0: \\mu \\leq 40 \\\\\n&H_1: \\mu > 40\n\\end{align}\n$$\n\nanv칛nd funktionen `t.test` f칬r att testa detta. Tips: l칛s i hj칛lpen `?t.test`.\n\n## 3. Centrala gr칛nsv칛rdessatsen\n\nAntag att data kommer fr친n en likforming (Uniform) f칬rdelning mellan 0 och 1, dvs $a=0$ och $b=1$ i den likformiga f칬rdelningen. Allts친: $X_1,X_2,\\ldots,X_n\\overset{iid}{\\sim}\\mathrm{Uniform}(0,1).$\n\n#### 游눩 Uppgift 3.1\n\nSimulera 10000 stickprov med vardera $n=2$ observationer och ber칛kna medelv칛rdet i varje stickprov. Rita ett histogram 칬ver dessa 10000 medelv칛rden.\n\n#### 游눩 Uppgift 3.2\n\nUpprepa Uppgift 3.1 f칬r $n=5$, $n=10$ och $n=30$ observationer i varje stickprov. Kommentera resultatet.\n\n#### 游눩 Uppgift 3.3\n\nUpprepa Uppgift 3.2, men ist칛llet f칬r att ber칛kna medelv칛rdet i varje stickprov s친 ska du ber칛kna statistikan\n\n$$\nx_{\\mathrm{max}}=\\max(x_1,x_2,\\ldots,x_n)\n$$\n\ndvs det h칬gsta v칛rdet i varje stickprov. Varf칬r verkar centrala gr칛nsv칛rdessatsen inte fungera h칛r?\n",
    "supporting": [
      "DatorLab6_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}